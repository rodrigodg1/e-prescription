"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const rust = __importStar(require("./rust"));
const JSON = __importStar(require("ts-typed-json"));
function isStringDict(x) {
    for (let key of Object.keys(x)) {
        if (x[key] !== null && typeof x[key] !== 'string') {
            return false;
        }
    }
    return true;
}
class BuildSettings {
    constructor(rustc, nodeVersion, env) {
        this.rustc = rustc;
        this.nodeVersion = nodeVersion;
        this.env = env;
    }
    match(other) {
        if (other.nodeVersion !== this.nodeVersion) {
            return false;
        }
        return Object.keys(this.env).every(key => {
            return (!this.env[key] && !other.env[key]) ||
                (this.env[key] === other.env[key]);
        });
    }
    static getNodeVersion() {
        return process.version;
    }
    static current(toolchain = 'default') {
        let rustcVersionResult = rust.spawnSync("rustc", ["--version"], toolchain);
        let nodeVersion = BuildSettings.getNodeVersion();
        if (rustcVersionResult.error) {
            if (rustcVersionResult.error.message.includes("ENOENT")) {
                throw new Error('Rust is not installed or rustc is not in your path.');
            }
            throw rustcVersionResult.error;
        }
        let rustc = rustcVersionResult.stdout
            .toString()
            .trim();
        return new BuildSettings(rustc, nodeVersion, {
            npm_config_target: process.env.npm_config_target || null,
            npm_config_arch: process.env.npm_config_arch || null,
            npm_config_target_arch: process.env.npm_config_target_arch || null,
            npm_config_disturl: process.env.npm_config_disturl || null,
            npm_config_runtime: process.env.npm_config_runtime || null,
            npm_config_build_from_source: process.env.npm_config_build_from_source || null,
            npm_config_devdir: process.env.npm_config_devdir || null,
            npm_config_node_engine: process.env.npm_config_node_engine || null,
            npm_config_nodedir: process.env.npm_config_nodedir || null,
            npm_config_node_gyp: process.env.npm_config_node_gyp || null,
            npm_config_platform: process.env.npm_config_platform || null
        });
    }
    static fromJSON(value) {
        value = JSON.asObject(value, "value");
        let { rustc, env, nodeVersion } = value;
        if (typeof rustc !== 'string') {
            throw new TypeError("value.rustc must be a string");
        }
        if ('nodeVersion' in value) {
            if (typeof nodeVersion !== 'string' && nodeVersion !== null) {
                throw new TypeError("value.nodeVersion must be a string or null");
            }
        }
        else {
            nodeVersion = null;
        }
        if (!JSON.isObject(env)) {
            throw new TypeError("value.env must be an object");
        }
        if (!isStringDict(env)) {
            throw new TypeError("value.env must be a string dict");
        }
        return new BuildSettings(rustc, nodeVersion, env);
    }
    toJSON() {
        return {
            "rustc": this.rustc,
            "nodeVersion": this.nodeVersion,
            "env": this.env
        };
    }
}
exports.default = BuildSettings;
